TASK: Migrate Admin Project from Turso Database to Prisma PostgreSQL Database

I need to transition this admin project from using the Turso database to our main Prisma PostgreSQL database with minimal disruption. Here are the complete details:

üéØ OBJECTIVE:
Replace all Turso database connections and queries with Prisma Client connections to our PostgreSQL database, maintaining all existing functionality.

üìä CURRENT DATABASE DETAILS:

NEW PRISMA DATABASE (Target):
DATABASE_URL=postgresql://neondb_owner:npg_XOFJ21kRlhpT@ep-plain-glitter-abljx7c3-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require

CURRENT TURSO DATABASE (To Replace):
TURSO_AUTH_TOKEN="eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE3NTcyNzQ1NDEsImlkIjoiNzdiYTRhYWQtYTI4My00N2I0LTkwNGYtOTA0MjZmZjBhYTJhIiwicmlkIjoiMGFhYTU2NzItMTc3OC00NzYzLTkxZDgtZTYwODI1NjdjODkwIn0.-Gpk2iP0ede-hwjlZSaSGM1UsEkthQdhX3Jj1FOUvAf72luj0b5Uo7-gM-yr8JsthmRRY83osWMSDpU4fKtwDA"
TURSO_DATABASE_URL="libsql://vosf-old-dbs-vercel-icfg-iyhpcldkzams285cfidsao6f.aws-eu-west-1.turso.io"

üóÑÔ∏è DATABASE SCHEMA INFORMATION:

The Prisma database contains these main models with the following relationships:

Core Models:
- User (id, email, username, displayName, avatarUrl, role, emailVerified, password, createdAt, updatedAt)
- UserProfile (id, userId, firstName, lastName, phone, about, shortAbout, location, rateTier1, rateTier2, rateTier3, showRates, socialUrls, isCrbChecked, isFeatured, isSpotlight, verificationLevel, homeStudioDescription, equipmentList, servicesOffered, showEmail, showPhone, showAddress, createdAt, updatedAt)
- Studio (id, ownerId, name, description, studioType, address, latitude, longitude, websiteUrl, phone, isPremium, isVerified, status, createdAt, updatedAt)

Relationships:
- User ‚Üî UserProfile (1:1 via userId)
- User ‚Üî Studio (1:many via ownerId)
- Each User should have one UserProfile
- Each UserProfile should be associated with one User
- Studios are owned by Users

Current Data Stats:
- Total Users: ~685
- Total UserProfiles: ~657 (28 users missing profiles)
- Total Studios: 657 active studios
- Studios with coordinates: 541

üîß MIGRATION STEPS NEEDED:

1. SETUP PRISMA:
npm install prisma @prisma/client
npm install -D prisma

2. CREATE PRISMA SCHEMA:
Create prisma/schema.prisma with the exact schema from the main project. The key models are User, UserProfile, and Studio with proper relationships.

3. ENVIRONMENT VARIABLES:
Update .env or .env.local:
DATABASE_URL="postgresql://neondb_owner:npg_XOFJ21kRlhpT@ep-plain-glitter-abljx7c3-pooler.eu-west-2.aws.neon.tech/neondb?sslmode=require"

4. REPLACE TURSO IMPORTS:
Find and replace all instances of:
- Turso client imports ‚Üí import { PrismaClient } from '@prisma/client'
- Turso database connections ‚Üí Prisma client connections
- LibSQL queries ‚Üí Prisma queries

5. UPDATE QUERY SYNTAX:
Convert from LibSQL/Turso syntax to Prisma syntax:
- db.execute() ‚Üí prisma.model.findMany(), prisma.model.create(), etc.
- Raw SQL queries ‚Üí Prisma query methods
- Turso transactions ‚Üí Prisma transactions

üéØ SPECIFIC REQUIREMENTS:

MAINTAIN ALL FUNCTIONALITY:
- Keep all existing admin features working
- Preserve all data access patterns
- Maintain the same API responses
- Keep all authentication and authorization

QUERY CONVERSION EXAMPLES:
// OLD TURSO:
const result = await db.execute("SELECT * FROM users WHERE role = ?", [role]);

// NEW PRISMA:
const result = await prisma.user.findMany({
  where: { role: role }
});

ERROR HANDLING:
- Add proper Prisma error handling
- Maintain existing error response formats
- Add connection retry logic if needed

üìã VALIDATION CHECKLIST:

After migration, verify:
- [ ] All admin dashboard pages load correctly
- [ ] User management functions work
- [ ] Studio management functions work
- [ ] Data filtering and searching works
- [ ] Authentication still functions
- [ ] All API endpoints return correct data
- [ ] No Turso references remain in code
- [ ] Environment variables are updated
- [ ] Database connections are stable

üö® CRITICAL NOTES:

1. Data Integrity: The Prisma database is the source of truth with 657 active studios
2. Relationships: Ensure User-UserProfile-Studio relationships are properly maintained
3. Performance: Use Prisma's include/select for efficient queries
4. Security: Keep the same authentication patterns
5. Backwards Compatibility: Maintain existing API response formats

üìÅ FILES TO FOCUS ON:

Look for files containing:
- turso, libsql, TURSO_, database connection logic
- Database query functions
- API routes that fetch data
- Admin dashboard components that display data

üîç SEARCH PATTERNS:

Find and replace these patterns:
- import.*turso ‚Üí Prisma imports
- TURSO_ ‚Üí DATABASE_URL
- .execute( ‚Üí Prisma query methods
- libsql ‚Üí @prisma/client

EXECUTE THIS MIGRATION SYSTEMATICALLY:
1. Set up Prisma configuration first
2. Replace database connections
3. Convert queries one file at a time
4. Test each component after conversion
5. Verify all functionality works
6. Remove all Turso dependencies

GOAL: Complete transition to Prisma PostgreSQL database while maintaining 100% of existing admin functionality.

PRISMA SCHEMA REFERENCE:

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  displayName   String?   @map("display_name")
  avatarUrl     String?   @map("avatar_url")
  role          UserRole  @default(USER)
  emailVerified Boolean   @default(false) @map("email_verified")
  password      String?
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  profile UserProfile?
  studios Studio[]

  @@map("users")
}

model UserProfile {
  id                      String  @id @default(cuid())
  userId                  String  @unique @map("user_id")
  firstName               String? @map("first_name")
  lastName                String? @map("last_name")
  phone                   String?
  about                   String?
  shortAbout              String? @map("short_about")
  location                String?
  rateTier1               String? @map("rate_tier_1")
  rateTier2               String? @map("rate_tier_2")
  rateTier3               String? @map("rate_tier_3")
  showRates               Boolean @default(false) @map("show_rates")
  facebookUrl             String? @map("facebook_url")
  twitterUrl              String? @map("twitter_url")
  linkedinUrl             String? @map("linkedin_url")
  instagramUrl            String? @map("instagram_url")
  youtubeUrl              String? @map("youtube_url")
  vimeoUrl                String? @map("vimeo_url")
  soundcloudUrl           String? @map("soundcloud_url")
  isCrbChecked            Boolean @default(false) @map("is_crb_checked")
  isFeatured              Boolean @default(false) @map("is_featured")
  isSpotlight             Boolean @default(false) @map("is_spotlight")
  verificationLevel       String  @default("NONE") @map("verification_level")
  homeStudioDescription   String? @map("home_studio_description")
  equipmentList           String? @map("equipment_list")
  servicesOffered         String? @map("services_offered")
  showEmail               Boolean @default(false) @map("show_email")
  showPhone               Boolean @default(false) @map("show_phone")
  showAddress             Boolean @default(false) @map("show_address")
  createdAt               DateTime @default(now()) @map("created_at")
  updatedAt               DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Studio {
  id          String      @id @default(cuid())
  ownerId     String      @map("owner_id")
  name        String
  description String?
  studioType  StudioType  @map("studio_type")
  address     String?
  latitude    Decimal?    @db.Decimal(10, 8)
  longitude   Decimal?    @db.Decimal(11, 8)
  websiteUrl  String?     @map("website_url")
  phone       String?
  isPremium   Boolean     @default(false) @map("is_premium")
  isVerified  Boolean     @default(false) @map("is_verified")
  status      StudioStatus @default(ACTIVE)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("studios")
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum StudioType {
  HOME_STUDIO
  COMMERCIAL_STUDIO
  MOBILE_STUDIO
}

enum StudioStatus {
  ACTIVE
  INACTIVE
  PENDING
  SUSPENDED
}

COMMON PRISMA QUERY PATTERNS:

// Find all users with profiles
const users = await prisma.user.findMany({
  include: {
    profile: true,
    studios: true
  }
});

// Find studios with owner info
const studios = await prisma.studio.findMany({
  include: {
    owner: {
      include: {
        profile: true
      }
    }
  }
});

// Count records
const userCount = await prisma.user.count();

// Create with relations
const user = await prisma.user.create({
  data: {
    email: "test@example.com",
    username: "testuser",
    profile: {
      create: {
        firstName: "Test",
        lastName: "User"
      }
    }
  }
});

// Update records
const updatedUser = await prisma.user.update({
  where: { id: userId },
  data: { displayName: "New Name" }
});

// Delete records
await prisma.user.delete({
  where: { id: userId }
});


