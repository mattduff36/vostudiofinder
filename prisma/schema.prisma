// VoiceoverStudioFinder Database Schema
// Modern PostgreSQL schema based on legacy MySQL structure

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  username      String   @unique
  displayName   String   @map("display_name")
  avatarUrl     String?  @map("avatar_url")
  role          Role     @default(USER)
  emailVerified Boolean  @default(false) @map("email_verified")
  password      String?  // For email/password auth
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  studios       Studio[]
  reviews       Review[]
  reviewsReceived  Review[] @relation("StudioOwnerReviews")
  reviewResponses  ReviewResponse[]
  sentMessages     Message[] @relation("MessageSender")
  receivedMessages Message[] @relation("MessageReceiver")
  connections   UserConnection[] @relation("UserConnections")
  connectedBy   UserConnection[] @relation("ConnectedUser")
  subscriptions        Subscription[]
  accounts             Account[]
  sessions             Session[]
  savedSearches        SavedSearch[]
  pendingSubscriptions PendingSubscription[]
  processedRefunds     Refund[]
  notifications        Notification[]
  reportsMade          ContentReport[] @relation("ReportsMade")
  reportsReceived      ContentReport[] @relation("ReportsReceived")
  reportsReviewed      ContentReport[] @relation("ReportsReviewed")

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Studio {
  id          String      @id @default(cuid())
  ownerId     String      @map("owner_id")
  name        String
  description String?     @db.Text
  studioType  StudioType  @map("studio_type")
  address     String?
  latitude    Decimal?    @db.Decimal(10, 8)
  longitude   Decimal?    @db.Decimal(11, 8)
  websiteUrl  String?     @map("website_url")
  phone       String?
  isPremium   Boolean     @default(false) @map("is_premium")
  isVerified  Boolean     @default(false) @map("is_verified")
  status      StudioStatus @default(ACTIVE)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  owner                User @relation(fields: [ownerId], references: [id])
  services             StudioService[]
  images               StudioImage[]
  reviews              Review[]
  pendingSubscriptions PendingSubscription[]

  @@map("studios")
}

model StudioService {
  id        String      @id @default(cuid())
  studioId  String      @map("studio_id")
  service   ServiceType
  
  studio    Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@unique([studioId, service])
  @@map("studio_services")
}

model StudioImage {
  id        String @id @default(cuid())
  studioId  String @map("studio_id")
  imageUrl  String @map("image_url")
  altText   String? @map("alt_text")
  sortOrder Int    @default(0) @map("sort_order")
  
  studio    Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@map("studio_images")
}

model Review {
  id          String      @id @default(cuid())
  studioId    String      @map("studio_id")
  reviewerId  String      @map("reviewer_id")
  ownerId     String      @map("owner_id") // For easy queries
  rating      Int         @db.SmallInt
  content     String?     @db.Text
  isAnonymous Boolean     @default(false) @map("is_anonymous")
  status      ReviewStatus @default(PENDING)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  studio   Studio          @relation(fields: [studioId], references: [id], onDelete: Cascade)
  reviewer User            @relation(fields: [reviewerId], references: [id])
  owner    User            @relation("StudioOwnerReviews", fields: [ownerId], references: [id])
  response ReviewResponse?

  @@map("reviews")
}

model ReviewResponse {
  id        String   @id @default(cuid())
  reviewId  String   @unique @map("review_id")
  authorId  String   @map("author_id")
  content   String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("review_responses")
}

model Message {
  id         String      @id @default(cuid())
  senderId   String      @map("sender_id")
  receiverId String      @map("receiver_id")
  subject    String?
  content    String      @db.Text
  isRead     Boolean     @default(false) @map("is_read")
  createdAt  DateTime    @default(now()) @map("created_at")

  // Relations
  sender     User @relation("MessageSender", fields: [senderId], references: [id])
  receiver   User @relation("MessageReceiver", fields: [receiverId], references: [id])

  @@map("messages")
}

model UserConnection {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  connectedUserId String @map("connected_user_id")
  accepted  Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user         User @relation("UserConnections", fields: [userId], references: [id])
  connectedUser User @relation("ConnectedUser", fields: [connectedUserId], references: [id])

  @@unique([userId, connectedUserId])
  @@map("user_connections")
}

model Subscription {
  id                    String            @id @default(cuid())
  userId                String            @map("user_id")
  stripeSubscriptionId  String?           @unique @map("stripe_subscription_id")
  stripeCustomerId      String?           @map("stripe_customer_id")
  paypalSubscriptionId  String?           @unique @map("paypal_subscription_id")
  paymentMethod         PaymentMethod     @default(STRIPE) @map("payment_method")
  status                SubscriptionStatus
  currentPeriodStart    DateTime?         @map("current_period_start")
  currentPeriodEnd      DateTime?         @map("current_period_end")
  cancelledAt           DateTime?         @map("cancelled_at")
  createdAt             DateTime          @default(now()) @map("created_at")
  updatedAt             DateTime          @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@map("subscriptions")
}

model SavedSearch {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  name      String
  filters   String   // JSON string of search filters
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("saved_searches")
}

model PendingSubscription {
  id                   String        @id @default(cuid())
  userId               String        @map("user_id")
  studioId             String        @map("studio_id")
  paypalSubscriptionId String?       @unique @map("paypal_subscription_id")
  stripeSessionId      String?       @unique @map("stripe_session_id")
  status               String        @default("PENDING_APPROVAL")
  paymentMethod        PaymentMethod @map("payment_method")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime      @updatedAt @map("updated_at")

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  studio Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@map("pending_subscriptions")
}

model Refund {
  id                     String       @id @default(cuid())
  stripeRefundId         String       @unique @map("stripe_refund_id")
  stripePaymentIntentId  String       @map("stripe_payment_intent_id")
  amount                 Int          // Amount in cents
  currency               String
  reason                 String?
  status                 RefundStatus
  processedBy            String       @map("processed_by")
  createdAt              DateTime     @default(now()) @map("created_at")
  updatedAt              DateTime     @updatedAt @map("updated_at")

  // Relations
  processedByUser User @relation(fields: [processedBy], references: [id])

  @@map("refunds")
}

model Notification {
  id          String           @id @default(cuid())
  userId      String           @map("user_id")
  type        NotificationType
  title       String
  message     String           @db.Text
  data        Json?            // Additional data for the notification
  read        Boolean          @default(false)
  readAt      DateTime?        @map("read_at")
  actionUrl   String?          @map("action_url")
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model ContentReport {
  id             String        @id @default(cuid())
  reporterId     String        @map("reporter_id")
  contentType    ContentType   @map("content_type")
  contentId      String        @map("content_id")
  reportedUserId String?       @map("reported_user_id")
  reason         ReportReason
  customReason   String?       @map("custom_reason")
  status         ReportStatus  @default(PENDING)
  reviewedById   String?       @map("reviewed_by_id")
  reviewedAt     DateTime?     @map("reviewed_at")
  resolution     String?       @db.Text
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")

  // Relations
  reporter     User  @relation("ReportsMade", fields: [reporterId], references: [id])
  reportedUser User? @relation("ReportsReceived", fields: [reportedUserId], references: [id])
  reviewedBy   User? @relation("ReportsReviewed", fields: [reviewedById], references: [id])

  @@map("content_reports")
}

// Enums
enum Role {
  USER
  STUDIO_OWNER
  ADMIN
}

enum StudioType {
  RECORDING
  PODCAST
  HOME
  PRODUCTION
  MOBILE
}

enum ServiceType {
  ISDN
  SOURCE_CONNECT
  SOURCE_CONNECT_NOW
  CLEANFEED
  SESSION_LINK_PRO
  ZOOM
  SKYPE
  TEAMS
}

enum StudioStatus {
  DRAFT
  ACTIVE
  INACTIVE
  PENDING
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  UNPAID
  INCOMPLETE
  SUSPENDED
}

enum PaymentMethod {
  STRIPE
  PAYPAL
}

enum RefundStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum NotificationType {
  MESSAGE_RECEIVED
  REVIEW_RECEIVED
  REVIEW_RESPONSE
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  STUDIO_VERIFIED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  SUBSCRIPTION_EXPIRING
}

enum ContentType {
  REVIEW
  MESSAGE
  STUDIO
  USER
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  INAPPROPRIATE
  FAKE_INFO
  COPYRIGHT
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}
